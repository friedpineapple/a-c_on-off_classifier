# -*- coding: utf-8 -*-
"""Main_Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V5eTVvTmCPl7vzU5nAkPiDimzeLtorPR
"""

#tools and data entry
import pandas as pd 
import matplotlib.pyplot as plt
from matplotlib import pyplot
import datetime as datetime
import math
import numpy as np
import seaborn as sns
from numpy import NaN

from google.colab import files
uploaded = files.upload()

import io
df_hum_in = pd.read_csv(io.BytesIO(uploaded['humidity_in.csv']))

import io
df_hum_out = pd.read_csv(io.BytesIO(uploaded['humidity_out.csv']))

import io
df_temp_in = pd.read_csv(io.BytesIO(uploaded['temperature_in.csv']))

import io
df_temp_out = pd.read_csv(io.BytesIO(uploaded['temperature_out.csv']))

import io
df_power = pd.read_csv(io.BytesIO(uploaded['ac_power.csv']))

import io
df_current = pd.read_csv(io.BytesIO(uploaded['ac_current.csv']))

import io
df_occup = pd.read_csv(io.BytesIO(uploaded['occupancy.csv']))

df_hum_in['statetime'] = pd.to_datetime(df_hum_in['statetime'])
df_hum_out['statetime'] = pd.to_datetime(df_hum_out['statetime'])
df_temp_in['statetime'] = pd.to_datetime(df_temp_in['statetime'])
df_temp_out['statetime'] = pd.to_datetime(df_temp_out['statetime'])
df_power['statetime'] = pd.to_datetime(df_power['statetime'])
df_current['statetime'] = pd.to_datetime(df_current['statetime'])

df_hum_in['humidity_in'] = pd.to_numeric(df_hum_in['humidity_in'], errors='coerce')
df_hum_out['humidity_out'] = pd.to_numeric(df_hum_out['humidity_out'], errors='coerce')
df_temp_in['temp_in'] = pd.to_numeric(df_temp_in['temp_in'], errors='coerce')
df_temp_out['temp_out'] = pd.to_numeric(df_temp_out['temp_out'], errors='coerce')
df_power['ac_pow_power'] = pd.to_numeric(df_power['ac_pow_power'], errors='coerce')
df_current['ac_pow_current'] = pd.to_numeric(df_current['ac_pow_current'], errors='coerce')

df_hum_in = df_hum_in.set_index('statetime') 
df_hum_out = df_hum_out.set_index('statetime')
df_temp_in = df_temp_in.set_index('statetime')
df_temp_out = df_temp_out.set_index('statetime')
df_power = df_power.set_index('statetime')
df_current = df_current.set_index('statetime')

df_hum_out = df_hum_out.resample('min').mean()
df_hum_in = df_hum_in.resample('min').mean()
df_temp_in = df_temp_in.resample('min').mean()
df_temp_out = df_temp_out.resample('min').mean()
df_power = df_power.resample('min').mean()
df_current = df_current.resample('min').mean()

df_hum_out = df_hum_out.sort_values(by=['statetime'])
df_hum_in = df_hum_in.sort_values(by=['statetime'])
df_temp_in = df_temp_in.sort_values(by=['statetime'])
df_temp_out = df_temp_out.sort_values(by=['statetime'])
df_power = df_power.sort_values(by=['statetime'])
df_current = df_current.sort_values(by=['statetime'])

df_hum_out['humidity_out'].interpolate(method='linear', inplace=True)
df_hum_in['humidity_in'].interpolate(method='linear', inplace=True)
df_temp_in['temp_in'].interpolate(method='linear', inplace=True)
df_temp_out['temp_out'].interpolate(method='linear', inplace=True)
#interpolation fills nan values

df_power['ac_pow_power'] = df_power['ac_pow_power'].fillna(0)

df_current['ac_pow_current'] = df_current['ac_pow_current'].fillna(0)

# Data Frame που τα περιλαμβάνει όλα χωρίς NaN
dflist = [df_hum_out, df_hum_in, df_temp_in, df_temp_out, df_power, df_current, df_occup]
df = df_hum_out
for i in range(1, 6):
  df = df.merge(dflist[i], on='statetime', how='inner', sort=True)

df
#inner join krataei mono ta koina datetimes twn sthlwn.

sns.heatmap(df.isnull(), cbar=False)
df.isnull().sum()

from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import PolynomialFeatures
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import Ridge
from sklearn.linear_model import Lasso
from sklearn.linear_model import ElasticNet
from sklearn.metrics import mean_squared_error
import math
from sklearn.tree import DecisionTreeRegressor
from sklearn.model_selection import train_test_split
from sklearn import metrics

#  Outer join Data Frame που περιέχει όλες τις τιμές συν τα κενά κελιά
dflist = [df_hum_out, df_hum_in, df_temp_in, df_temp_out, df_power, df_current, df_occup]
dff = df_hum_out
for i in range(1, 6):
  dff = dff.merge(dflist[i], on='statetime', how='outer', sort=True)

dff['ac_pow_power'] = dff['ac_pow_power'].fillna(0)

corrmat = dff.corr() 

f, ax = plt.subplots(figsize =(9, 8)) 
sns.heatmap(corrmat, ax = ax, cmap ="YlGnBu", linewidths = 0.1)

dff

# Data frame που περιλαμβάνει τις κοινές σειρές με humidity out και temperature out προκειμένου να εκπαιδευτούν
df1 = df_hum_out.merge(df_temp_out, on='statetime', how='inner', sort=True)

df1

plt.scatter(df1['humidity_out'], df1['temp_out'])

# Εδώ ξεκινάει το linear regression μεταξύ humidity out και temperature out
X = df1.humidity_out.values.reshape((-1,1))
y = df1.temp_out

model = LinearRegression()
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

model = model.fit(X_train,y_train)

r_sq = model.score(X_train, y_train)   #oso kalytero regression toso o r^2 coefficient teinei sthn monada
print('coefficient of determination:', r_sq)

print('intercept:', model.intercept_)
print('slope:', model.coef_)

y_pred = model.predict(X_test)
print('predicted response:', y_pred, sep='\n')

print("MSE:",metrics.mean_squared_error(y_test, y_pred))

plt.scatter(X, y)
plt.plot(X_test, y_pred, color='red')
plt.show()

# Αφαιρούμε τις σειρές που το humidity out είναι NaN στο dff
dff = dff.dropna(subset=['humidity_out'])
dff.humidity_out.isnull().sum()
#me ayton ton tropo kratame sto dff mono 19-24 oct

dff

# Φτιάχνουμε μια κενή στήλη για να βάλουμε τις καινούργιες τιμές 
# που θα προκύψουν για το temperature out από το regression
from numpy import nan
dff['new_temp_out'] = np.nan

dff['new_temp_out'] = model.predict(dff.humidity_out.values.reshape((-1,1)))

# Συμπληρώνουμε τα κενά κελιά του temp_out με τις καινούργιες τιμές που βρήκαμε από το new_temp_out
for i in range(0, len(dff)):
  if math.isnan(dff['temp_out'][i]):
    dff['temp_out'][i] = dff['new_temp_out'][i]

plt.plot(dff['temp_out'])
plt.plot(dff['new_temp_out'])

# Αφαιρούμε τη στήλη new_temp_out
dff = dff.drop(columns='new_temp_out')

plt.plot(dff['humidity_out']['2019-10-20 05:00:00':'2019-10-24 04:43:00'])
plt.plot(dff['temp_out']['2019-10-20 05:00:00':'2019-10-24 04:43:00'])

dff = dff['2019-10-20 18:00:00':'2019-10-24 04:43:00']
#dff = dff['2019-10-20 05:00:00':'2019-10-24 04:43:00']
#αφαίρεση μετρήσσων λόγω απρόβλεπτων τιμών υγεσίας της ημέρας 19/10 (βροχή, ελλιπή δεδομένα)

dff

dff.corr()

a = dff.dropna(subset=['humidity_out', 'temp_out', 'ac_pow_power', 'temp_in'])

a

# Εκπαίδευση μοντέλου για να βρούμε το temperature in συναρτήσει των humidity out, temp out και ac_power
# Επιλέγουμε ένα Data Frame που περιέχει τις 3 μεταβλητές, χωρίς να περιέχει κενά
X = a.iloc[:, [0,3,4]]
y = a.iloc[:, 2]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

model2 = model.fit(X_train,y_train)

r_sq = model2.score(X_train, y_train)
print('coefficient of determination:', r_sq)

test_score = model2.score(X_test, y_test)
print('Test score:', test_score)

print('intercept:', model2.intercept_)
print('slope:', model2.coef_)

y_pred = model2.predict(X_test)
print('predicted response:', y_pred, sep='\n')

print("MSE:",metrics.mean_squared_error(y_test, y_pred))

b = dff[['humidity_out', 'temp_out', 'ac_pow_power']]
#['2019-10-20 03:18:00':'2019-10-24 05:58:00']

b = b.dropna(subset=['ac_pow_power'])

b

b.isna().sum()

b['new_temp_in'] = model2.predict(b)

dff = dff.merge(b['new_temp_in'], how='outer', on='statetime', sort='True' )

dff

dff['new_temp_in'].isna().sum()

#plt.plot()
plt.plot(dff['temp_out'])
plt.plot(dff['temp_in'])
plt.plot(dff['new_temp_in'])

for i in range(0, len(dff)):
  if math.isnan(dff['temp_in'][i]):
    dff['temp_in'][i] = dff['new_temp_in'][i]

plt.plot(dff['temp_in'])
plt.plot(dff['temp_out'])

dff = dff.drop(columns='new_temp_in')

plt.plot(dff['temp_out'])
plt.plot(dff['temp_in'])
plt.plot(dff['humidity_out'])
plt.plot(dff['ac_pow_power'])
#plt.plot(dff['humidity_in'])

dff.isna().sum()

corrfinal = dff.corr()

corrfinal

# εκπαίδευση μοντέλου για να συμπληρώσουμε τις τιμές του humidity in συναρτήσει του humidity out και temperature in
a = dff.dropna(subset=['humidity_out','humidity_in', 'temp_in'])

a['humidity_in'].isna().sum()

X = a.iloc[:, [0,2]]
X.isnull().sum()

X

y = a.iloc[:, 1]
y.isnull().sum()

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

model3 = LinearRegression()
model3 = model.fit(X_train,y_train)

r_sq = model3.score(X_train, y_train)
print('coefficient of determination:', r_sq)

test_score = model3.score(X_test, y_test)
print('Test_score:', test_score)

print('intercept:', model3.intercept_)
print('slope:', model3.coef_)

y_pred = model3.predict(X_test)
print('predicted response:', y_pred, sep='\n')

print("MSE:",metrics.mean_squared_error(y_test, y_pred))

x = dff.iloc[:, [0,2]]

x

x.isnull().sum()

x['new_hum_in'] = model3.predict(x)

#flag

x

dff = dff.merge(x['new_hum_in'], how='outer', on='statetime', sort=True)

for i in range(0, len(dff)):
  if math.isnan(dff['humidity_in'][i]):
    dff['humidity_in'][i] = dff['new_hum_in'][i]

plt.plot(dff['temp_out'],label = 'temp_out')
plt.plot(dff['ac_pow_power'])
plt.plot(dff['temp_in'])
plt.plot(dff['humidity_in'])
plt.plot(dff['humidity_out'])
plt.show()

dff = dff.drop(columns='new_hum_in')

df_occup['statetime'] = pd.to_datetime(df_occup['statetime'])

df_occup = df_occup.set_index('statetime')

df_occup = df_occup.replace("EA674E", 1)

df_occup = df_occup.resample('min').max()

df_occup.isnull().sum()

dff = dff.merge(df_occup, how='outer', on='statetime')

dff['motion_detected'] = dff['motion_detected'].fillna(0)

from sklearn import tree

dff['AC'] = dff['ac_pow_power']

dff['AC'] = dff['AC'].fillna(0)

dff

corrmat = dff.corr() 

f, ax = plt.subplots(figsize =(9, 8)) 
sns.heatmap(corrmat, ax = ax, cmap ="YlGnBu", linewidths = 0.1)

dff

#dff['AC'] = pd.cut(dff['AC'],2,labels=['off', 'on'])
for i in range(0, len(dff['AC'])):
  if dff['AC'][i] != 0:
    dff['AC'][i] = 1

#dff['AC'] =dff['AC'].fillna('off')

dff['AC'].isna().sum()

verydff = dff

verydff.corr()

verydff = verydff.drop(columns='ac_pow_power')

verydff = verydff.drop(columns='ac_pow_current')

verydff.isna().sum()

verydff

XX = verydff.dropna(subset=['humidity_in','humidity_out','temp_in','temp_out'])

XX

X = XX.iloc[:,:-1]
y= XX.iloc[:, -1]

XX.isna().sum()

X

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

model4 = tree.DecisionTreeClassifier()

model4 = model4.fit(X_train, y_train)

y_pred = model4.predict(X_test)

from sklearn.metrics import confusion_matrix
print(confusion_matrix(y_test, y_pred, labels=None, sample_weight=None, normalize=None))

print("Accuracy:",metrics.accuracy_score(y_test, y_pred)) #swsta to vgazei epalhtheysh me xeri

from sklearn.metrics import recall_score
recall_score(y_test, y_pred, average = 'micro')

metrics.recall_score(y_test, y_pred)

from sklearn.metrics import precision_score
precision_score(y_test, y_pred)

from sklearn.metrics import f1_score
f1_score(y_test, y_pred)

from sklearn.metrics import confusion_matrix
confusion_matrix(y_test, y_pred, labels=None, sample_weight=None, normalize=None)

#Logistic regression
from sklearn.linear_model import LogisticRegression

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
clf = LogisticRegression(random_state=0).fit(X_train, y_train)
y_pred_lr = clf.predict(X_test)

recall_score(y_test, y_pred_lr, average='micro')

precision_score(y_test, y_pred_lr, average = 'micro')

f1_score(y_test, y_pred_lr, average='micro')

metrics.accuracy_score(y_test, y_pred_lr)

from sklearn.ensemble import RandomForestClassifier
rfc=RandomForestClassifier()
for a in range(10):
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) 
  rfc = rfc.fit(X_train,y_train,)
  y_pred = rfc.predict(X_test)
  print("Accuracy:",metrics.accuracy_score(y_test, y_pred))

recall_score(y_test, y_pred, average='micro')

precision_score(y_test, y_pred, average='micro')

f1_score(y_test, y_pred, average='micro')

from sklearn.svm import SVC
clf = SVC(gamma= 'scale', kernel = 'rbf')
#clf = SVC(gamma= 'auto', kernel = 'linear')
#clf = SVC(gamma= 'scale', kernel = 'poly', degree= 3) degree= 3 by default

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
svm_model = clf.fit(X, y)
#print(clf.predict())
y_pred_svm = clf.predict (X_test)

print("Accuracy test:",metrics.accuracy_score(y_test, y_pred_svm))

recall_score(y_test, y_pred_svm)

precision_score(y_test, y_pred_svm, average='micro')

f1_score(y_test, y_pred_svm)
confusion_matrix(y_test, y_pred, labels=None, sample_weight=None, normalize=None)

from google.colab import files
uploaded = files.upload()

import io
df_hum_in = pd.read_csv(io.BytesIO(uploaded['humidity_in_test.csv']))
import io
df_hum_out = pd.read_csv(io.BytesIO(uploaded['humidity_out_test.csv']))
import io
df_occup = pd.read_csv(io.BytesIO(uploaded['occupancy_test.csv']))
import io
df_temp_in = pd.read_csv(io.BytesIO(uploaded['temperature_in_test.csv']))
import io
df_temp_out = pd.read_csv(io.BytesIO(uploaded['temperature_out_test.csv']))
import io
df_ac_statetime= pd.read_csv(io.BytesIO(uploaded['ac_statetime_test.csv']))

df_hum_in['statetime'] = pd.to_datetime(df_hum_in['statetime'])
df_hum_out['statetime'] = pd.to_datetime(df_hum_out['statetime'])
df_temp_in['statetime'] = pd.to_datetime(df_temp_in['statetime'])
df_temp_out['statetime'] = pd.to_datetime(df_temp_out['statetime'])
df_occup['statetime'] = pd.to_datetime(df_occup['statetime'])

df_ac_statetime['statetime'] = pd.to_datetime(df_ac_statetime['statetime'])

df_hum_in['humidity_in'] = pd.to_numeric(df_hum_in['humidity_in'], errors='coerce')
df_hum_out['humidity_out'] = pd.to_numeric(df_hum_out['humidity_out'], errors='coerce')
df_temp_in['temp_in'] = pd.to_numeric(df_temp_in['temperature_in'], errors='coerce')
df_temp_out['temp_out'] = pd.to_numeric(df_temp_out['temperature_out'], errors='coerce')

df_hum_in = df_hum_in.set_index('statetime')   
df_hum_out = df_hum_out.set_index('statetime')
df_temp_in = df_temp_in.set_index('statetime')
df_temp_out = df_temp_out.set_index('statetime')

df_hum_out = df_hum_out.resample('min').mean()
df_hum_in = df_hum_in.resample('min').mean()
df_temp_in = df_temp_in.resample('min').mean()
df_temp_out = df_temp_out.resample('min').mean()

df_hum_out = df_hum_out.sort_values(by=['statetime'])
df_hum_in = df_hum_in.sort_values(by=['statetime'])
df_temp_in = df_temp_in.sort_values(by=['statetime'])
df_temp_out = df_temp_out.sort_values(by=['statetime'])

df_hum_out['humidity_out'].interpolate(method='linear', inplace=True)
df_hum_in['humidity_in'].interpolate(method='linear', inplace=True)
df_temp_in['temp_in'].interpolate(method='linear', inplace=True)
df_temp_out['temp_out'].interpolate(method='linear', inplace=True)

dflist = [df_hum_out, df_hum_in, df_temp_in, df_temp_out, df_ac_statetime]
newdf = df_hum_out
for i in range(1, 5):
  newdf = newdf.merge(dflist[i], on='statetime', how='outer', sort=True)

df_occup['statetime'] = pd.to_datetime(df_occup['statetime'])

df_occup = df_occup.set_index('statetime')

df_occup = df_occup.replace("EA674E", 1)

df_occup = df_occup.resample('min').max()

newdf = newdf.merge(df_occup, on='statetime', how='outer', sort=True)

newdf['motion_detected'] = newdf['motion_detected'].fillna(0)

newdf = newdf.set_index('statetime')

newdf = newdf.dropna(how='any')

newdf

X = newdf.dropna()

X

X['AC'] = np.nan

XA = X.iloc[:, : -1]

XA

XA.isna().sum()

XA['AC'] = model4.predict(XA)

XA.isna().sum()

XA['motion_detected'] = XA['motion_detected'].fillna(0)

XA.tail()

plt.plot(XA['AC'])
plt.plot(XA['temp_in'])

# σε αυτό το σημείο θα μπορούσαμε να αναπτύξουμε ένα προγνωστικό μοντέλο με την παρακάτω προσθήκη, 
# έτσι ώστε η τιμή του AC να συνυπολογίζει και το αν υπάρχει κίνηση 15 λεπτά μετά και 15 λεπτά πριν

for i in range(15, len(XA)):
  if ((XA['AC'][i] == 1) &  (XA['motion_detected'][i] == 0)):
    if (XA['motion_detected'][i-15:i+15].sum() == 0):
      XA['AC'][i] = 0

plt.plot(XA['temp_out']['2019-09-11 04:31:00':'2019-09-12 23:00:00'])
plt.plot(XA['temp_in']['2019-09-11 04:31:00':'2019-09-12 23:00:00']) 
plt.plot(XA['humidity_in']['2019-09-11 04:31:00':'2019-09-12 23:00:00']) 
plt.plot(XA['AC']['2019-09-11 04:31:00':'2019-09-12 23:00:00'])

XA['AC'][XA['AC'] == 1].count()

#giorgosextract
XA['AC'].to_csv(r'ac_operation.csv')
files.download('ac_operation.csv')

######### PCA
from mpl_toolkits.mplot3d import Axes3D
from sklearn.decomposition import PCA

DF = XA
DF = DF.reset_index()
DF = DF.drop(columns='statetime')

X = DF.iloc[:, :-2]
y = DF.iloc[:, -2]

pca = PCA(n_components=2)
principalComponents = pca.fit_transform(X)
principalDf = pd.DataFrame(data = principalComponents, columns = ['principal component 1', 'principal component 2'])
finalDf = pd.concat([principalDf, DF[['AC']]], axis = 1)

fig = plt.figure(figsize = (8,8))
ax = fig.add_subplot(1,1,1) 
ax.set_xlabel('Principal Component 1', fontsize = 15)
ax.set_ylabel('Principal Component 2', fontsize = 15)
ax.set_title('2 component PCA', fontsize = 20)
targets = [0, 1]
colors = ['r', 'g']
for target, color in zip(targets,colors):
    indicesToKeep = finalDf['AC'] == target
    ax.scatter(finalDf.loc[indicesToKeep, 'principal component 1']
               , finalDf.loc[indicesToKeep, 'principal component 2']
               , c = color
               , s = 50)
ax.legend(targets)
ax.grid()

for i in range(0, len(DF)):
  if DF['AC'][i] == "off":
    DF['AC'][i] = DF['AC'][i].replace("off", '0')
  else: 
     DF['AC'][i] = DF['AC'][i].replace("on", '1')

y = DF.AC
plt.figure(2, figsize=(8, 6))

plt.scatter(DF['temp_in'], DF['temp_out'], c=DF['AC'],  cmap=plt.cm.Set1, edgecolor='k')

DF2 = verydff

DF2['test_ac'] = np.nan

DF2['test_ac'] = DF2['AC']

DF2

for i in range(0, len(DF2)):
  if DF2['test_ac'][i] == "off":
    DF2['test_ac'][i] = DF2['test_ac'][i].replace("off", '0')
  else: 
     DF2['test_ac'][i] = DF2['test_ac'][i].replace("on", '1')

y = DF2.test_ac
plt.figure(2, figsize=(8, 6))

plt.scatter(DF2['temp_in'], DF2['temp_out'], c=DF2['test_ac'],  cmap=plt.cm.Set1, edgecolor='k')

plt.figure(2, figsize=(8, 6))

plt.scatter(DF2['temp_in'], DF2['temp_out'],   cmap=plt.cm.Set1, edgecolor='k')

DF2 = DF2.reset_index()
DF2 = DF2.drop(columns='statetime')

DF2 = DF2.dropna()

X = DF2.iloc[:,: -2]
y = DF2.iloc[:, -2]

y

pca = PCA(n_components=2)
principalComponents = pca.fit_transform(X)
principalDf = pd.DataFrame(data = principalComponents, columns = ['principal component 1', 'principal component 2'])
finalDf = pd.concat([principalDf, DF2[['AC']]], axis = 1)

fig = plt.figure(figsize = (8,8))
ax = fig.add_subplot(1,1,1) 
ax.set_xlabel('Principal Component 1', fontsize = 15)
ax.set_ylabel('Principal Component 2', fontsize = 15)
ax.set_title('2 component PCA', fontsize = 20)
targets = [0, 1]
colors = ['r', 'g']
for target, color in zip(targets,colors):
    indicesToKeep = finalDf['AC'] == target
    ax.scatter(finalDf.loc[indicesToKeep, 'principal component 1']
               , finalDf.loc[indicesToKeep, 'principal component 2']
               , c = color
               , s = 50)
ax.legend(targets)
ax.grid()

from sklearn.cluster import KMeans
X = dff.dropna(subset=['ac_pow_power','temp_in']).iloc[:, [2,4]]
kmeans = KMeans(n_clusters=3, random_state=1000).fit(X)
#kmeans.labels_
kmeans.predict(X)
#plt.plot (X)
c = kmeans.cluster_centers_
plt.plot (c)

plt.scatter(x= X['ac_pow_power'], y= X['temp_in'])
plt.scatter(x=c[:, 1],y= c[:, 0])

from sklearn.decomposition import TruncatedSVD
from scipy.sparse import random as sparse_random
from sklearn.random_projection import sparse_random_matrix

svd = TruncatedSVD(n_components=2, n_iter=7, random_state=42)

final = X.merge(df_ac_statetime['statetime'], on='statetime', how='inner', sort=True)

final

final = final.set_index('statetime')

# εδώ βάζουμε ότι μέρα θέλουμε
finald = final['2019-09-15 04:31:00':'2019-09-15 23:00:00']

plt.plot(finald['temp_in'])
plt.plot(finald['temp_out'])
plt.plot(finald['AC'])

#giorgos svm

from sklearn.svm import SVC
clf = SVC(gamma= 'scale', kernel = 'rbf')
#clf = SVC(gamma= 'auto', kernel = 'linear')
#clf = SVC(gamma= 'scale', kernel = 'poly', degree= 3) degree= 3 by default
X = dff.iloc[:, [0,1,2,3]]
y = dff.iloc[:, 5]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
svm_model = clf.fit(X, y)
#print(clf.predict())
y_pred_svm = clf.predict (X_test)

"""12 me 13 septemvriou.. false interpolate logw elleipshs metrhsewn na mh lhfthei ypopsin"""